/*******************************************************************************************************************//**
 * @file program3.cpp
 * @brief C++ example of traffic counting program in Open CV
 * @author Reety Gyawali (1001803756)
 **********************************************************************************************************************/

// include necessary dependencies
#include <iostream>
#include <cstdio>
#include "opencv2/opencv.hpp"
#include <opencv2/tracking.hpp>
#include <opencv2/core/ocl.hpp>

// configuration parameters
#define NUM_COMNMAND_LINE_ARGUMENTS 1
#define DISPLAY_WINDOW_NAME "Video Frame"



int main(int argc, char **argv)
{
    // store video capture parameters
    std::string fileName;

    // validate and parse the command line arguments
    if(argc != NUM_COMNMAND_LINE_ARGUMENTS + 1)
    {
        std::printf("USAGE: %s <file_path> \n", argv[0]);
        return 0;
    }
    else
    {
        fileName = argv[1];
    }

    // open the video file
    cv::VideoCapture capture(fileName);
    if(!capture.isOpened())
    {
        std::printf("Unable to open video source, terminating program! \n");
        return 0;
    }

    // get the video source parameters
    int captureWidth = static_cast<int>(capture.get(cv::CAP_PROP_FRAME_WIDTH));
    int captureHeight = static_cast<int>(capture.get(cv::CAP_PROP_FRAME_HEIGHT));
    int captureFPS = static_cast<int>(capture.get(cv::CAP_PROP_FPS));
    std::cout << "Video source opened successfully (width=" << captureWidth << " height=" << captureHeight << " fps=" << captureFPS << ")!" << std::endl;

    // create image window
    cv::namedWindow("fgmask", cv::WINDOW_AUTOSIZE);
	//cv::namedWindow(DISPLAY_WINDOW_NAME, cv::WINDOW_AUTOSIZE);

    // set background filtering parameters
    const int bgHistory = 200;
    const float bgThreshold = 500;
    const bool bgShadowDetection = false;
    cv::Mat fgMask; //fg mask generated by MOG2 method
    cv::Ptr<cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    pMOG2 = cv::createBackgroundSubtractorMOG2(bgHistory, bgThreshold, bgShadowDetection);

    // process data until program termination
    bool doCapture = true;
    int frameCount = 0;
    while(doCapture)
    {
        // attempt to acquire and process an image frame
        cv::Mat captureFrame;
        cv::Mat grayFrame;

        bool captureSuccess = capture.read(captureFrame);
        if(captureSuccess)
        {
			// pre-process the raw image frame
            cv::cvtColor(captureFrame, grayFrame, cv::COLOR_BGR2GRAY);
            cv::normalize(grayFrame, grayFrame, 0, 255, cv::NORM_MINMAX, CV_8UC1);

			// extract the foreground mask from image
			pMOG2->apply(grayFrame, fgMask);

            // find the image edges
            cv::Mat imageEdges;
            cv::Canny(fgMask, imageEdges, 100, 200);
            
            // erode and dilate the edges to remove noise
            cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(20, 20));
            cv::Mat edgesDilated;
            cv::dilate(imageEdges, edgesDilated, kernel);
            cv::dilate(edgesDilated, edgesDilated, kernel);
            cv::Mat edgesEroded;
            cv::erode(edgesDilated, edgesEroded, kernel);

            // locate the image contours (after applying a threshold or canny)
            std::vector<std::vector<cv::Point> > contours;
            cv::findContours(edgesEroded, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

            // draw the rectangles
            for (const auto& contour : contours) {
                cv::Rect boundingBox = cv::boundingRect(contour);
                cv::rectangle(captureFrame, boundingBox, cv::Scalar(0, 0, 255));
            }

            cv::imshow("fgmask", fgMask);
			//cv::imshow(DISPLAY_WINDOW_NAME, captureFrame);
            //std::cout <<  frameCount << std::endl;

            // check for program termination
            if((char) cv::waitKey(1) == 'q')
            {
                doCapture = false;
            }
        }
        else
        {
            std::printf("Unable to acquire image frame! \n");
        }
    }

    // release program resources before returning
    capture.release();
    cv::destroyAllWindows();
}